import os
import io
import pandas as pd
import numpy as np
import requests
from typing import Union
from PIL import Image
from owslib.wmts import WebMapTileService, TileMatrixSet
from logzero import logger
from object_detection_ign.utils import compute_tile_position
from tqdm import trange


class SatelliteView:
    """A representation of a given location on Earth. It is represented by a latitude, a longitude, a zoom level and an image of the local zone.
    It is generated by a WMTS Client.
    """

    def __init__(self):
        self.latitude = 0.0
        self.longitude = 0.0
        self.zoom_level = 0
        self.address = None
        self.image: Image.Image = None

    def show_image(self):
        """Shows the image.
        """
        self.image.show()

    @property
    def image_array(self):
        temp_array = np.array(self.image)
        array_shape = temp_array.shape
        temp_array = np.reshape(temp_array, [1, array_shape[0], array_shape[1], 3])
        return temp_array

    def save_image(self, export_path: str, file_extension="PNG"):
        """Exports the image as a file with the given file extension.

        Args:
            export_path (str): Exported file path
        """
        self.image.save(export_path, file_extension)

    def crop_image_center(self, new_width: int, new_length: int):
        """Crops an aerial image to the new desired width and length, starting from the center of the image.
        This design helps to stay centered on the initial latitude and longitude provided by the user.
        Note: the transformation is perfomed in-place.

        Args:
            new_width (int): new desired image width
            new_length (int): new desired image length
        """
        old_width, old_length = self.image.size
        x_center, y_center = old_width // 2, old_length // 2
        new_left = x_center - new_width // 2
        new_upper = y_center - new_length // 2
        new_right = x_center + new_width // 2
        new_lower = y_center + new_length // 2
        self.image = self.image.crop([new_left, new_upper, new_right, new_lower])
        logger.info(
            f"Resized image from size {old_width, old_length} to size {self.image.size}."
        )


class WMTSClient:
    """A WMTS (Web Map Tile Service) Client, used to connect to a WMTS Server. It connects to a given url, with a given version and with
    a chosen TileMatrixSet. It also shows the available zoom levels on the server. It produces SatelliteView objects.
    """

    def __init__(
        self, url: str, correspondance_table_path: str, correspondance_table_url: str
    ):
        self.wmts_server_url: str = url
        self.correspondance_table_url: str = correspondance_table_url
        self.wmts_instance = WebMapTileService(self.wmts_server_url, version="1.0.0")
        self.matrix_set: TileMatrixSet = self.wmts_instance.tilematrixsets["PM"]
        self.available_options = self._load_available_options(correspondance_table_path)

    def _load_available_options(self, correspondance_table_path: str) -> list:
        """Loads a correspondance table indicating what each zoom level roughly represents (e.g a street, a country...).
        It only contains zoom levels which are available on the WMTS server.

        Args:
            correspondance_table_path (str): a path towards the file containing the correspondance table

        Returns:
            list: a list containing each zoom level and what it represents
        """
        if os.path.exists(correspondance_table_path):
            logger.info("Existing correspondance table found, loading it now.")
            correspondance_table = pd.read_csv(correspondance_table_path, sep=";")
        else:
            logger.warning(
                "No correspondance table found, building one now from the given url."
            )
            correspondance_table = pd.read_html(self.correspondance_table_url)[0]
            correspondance_table["Usage suggestion"] = correspondance_table[
                "Usage suggestion"
            ].fillna(method="ffill")
            correspondance_table["New legend"] = (
                correspondance_table["Zoom level"].astype(str)
                + " - "
                + correspondance_table["Scale"].astype(str)
                + " - "
                + correspondance_table["Usage suggestion"]
            )
            correspondance_table = correspondance_table.set_index("Zoom level")
            correspondance_table.to_csv(correspondance_table_path, sep=";")

        available_zoom_levels = list(
            set(correspondance_table.index).intersection(
                set([int(key) for key in self.matrix_set.tilematrix.keys()])
            )
        )
        correspondance_table = correspondance_table.iloc[
            available_zoom_levels
        ].sort_index()
        available_options = correspondance_table.loc[:, "New legend"].to_list()
        return available_options

    def list_available_zoom_options(self) -> list:
        """Lists all available zoom levels and their description.

        Returns:
            list: a list containing each zoom level and what it represents
        """
        return self.available_options

    def list_available_layers(self) -> list:
        """Lists all available zoom levels and their description.

        Returns:
            list: a list containing each zoom level and what it represents
        """
        return self.wmts_instance.contents.keys()

    def reverse_geocoding(
        self, address: str
    ) -> tuple[Union[int, None], Union[int, None], bool]:
        """This functions performs an API call with the target address to the OpenStreetMap API.
        A longitude and a latitude are then returned.

        Args:
            address (str): postal address of the location

        Returns:
            latitude (int|None): latitude of the address if found. Returns None if no address is found.
            longitude (int|None): latitude of the address if found. Returns None if no address is found.
            found_coordinates (bool): returns True if coordinates where found, False otherwise.
        """
        target_url = (
            f"https://nominatim.openstreetmap.org/search?q={address}&format=json"
        )
        target_url = target_url.replace(",", "%2C")
        target_url = target_url.replace(" ", "+")

        r = requests.get(target_url)
        found_coordinates = True
        if r.status_code == 200:
            try:
                coordinates = r.json()[0]
                latitude, longitude = coordinates["lat"], coordinates["lon"]
            except:
                print(f"Address not found for: {target_url}")
                latitude, longitude = None, None
                found_coordinates = False
        else:
            print(f"Error {r.status_code} ocurred on the request")
            latitude, longitude, found_coordinates = None, None, False
        return latitude, longitude, found_coordinates

    def get_concat_image(
        self,
        grid_length: int,
        grid_width: int,
        tile_row: int,
        tile_column: int,
        layer: str,
        zoom_level: int,
    ) -> Image.Image:
        """Given a specific layer, zoom level, tile row and tile column, fetches all of the tiles around the tile containing the
        desired location. The number of tiles is personalized

        Args:
            grid_length (int): number of tiles along the image length
            grid_width (int): number of tiles along the image width
            tile_row (int): WMTS row where the central tile is located
            tile_column (int): WMTS column where the central tile is located
            layer (str): name of the layer containing the images in the WMTS server
            zoom_level (int): zoom level to use on the WMTS server
        Returns:
            Image.Image: an image formed by the concatenated tiles
        """
        total_width = 256 * grid_width
        total_height = 256 * grid_length
        image = Image.new("RGB", (total_width, total_height))
        for i, row in enumerate(trange(tile_row - 1, tile_row + 2)):
            for j, col in enumerate(range(tile_column - 1, tile_column + 2)):
                request = self.wmts_instance.gettile(
                    layer=layer,
                    tilematrixset="PM",
                    tilematrix=zoom_level,
                    row=row,
                    column=col,
                )
                temp_img = Image.open(io.BytesIO(request.read()))
                image.paste(temp_img, (j * 256, i * 256))
        return image

    def create_satellite_view_from_address(
        self, address: str, layer: str, zoom_level: int, grid_length=3, grid_width=3
    ) -> SatelliteView:
        """Creates a new SatelliteView object from a postal address. The location search is performed through the OpenStreetMap API.
        The function searches for the tile containing the point, then loads a number of tiles around this central tile depending on the
        desired grid length and width. By default, a 768*786 pixels image (3 tiles * 3 tiles of 256*256 pixels) is produced.

        Args:
            address (str): postal address of the location
            layer (str): name of the layer containing the images in the WMTS server
            zoom_level (int): zoom level to use on the WMTS server
            grid_length (int, optional): number of tiles on the length of the image. Defaults to 3.
            grid_width (int, optional): number of tiles on the width of the image. Defaults to 3.

        Returns:
            SatelliteView: a SatelliteView containing a custom image of the desired location
        """
        satellite_view = SatelliteView()
        satellite_view.address = address
        satellite_view.zoom_level = zoom_level
        (
            satellite_view.latitude,
            satellite_view.longitude,
            found_coordinates,
        ) = self.reverse_geocoding(address)
        tile_row, tile_column = compute_tile_position(
            self.matrix_set,
            zoom_level,
            satellite_view.longitude,
            satellite_view.latitude,
        )
        satellite_view.image = self.get_concat_image(
            grid_length, grid_width, tile_row, tile_column, layer, zoom_level
        )
        return satellite_view

    def create_satellite_view_from_position(
        self,
        latitude: float,
        longitude: float,
        layer: str,
        zoom_level: int,
        grid_length=3,
        grid_width=3,
    ) -> SatelliteView:
        """Creates a new SatelliteView object from a latitude and a longitude. This method is more precise than the postal address one.
        The function searches for the tile containing the point, then loads a number of tiles around this central tile depending on the
        desired grid length and width. By default, a 768*786 pixels image (3 tiles * 3 tiles of 256*256 pixels) is produced.

        Args:
            latitude (float): the latitude of the point to fetch
            longitude (float): the latitude of the point to fetch
            layer (str): name of the layer containing the images in the WMTS server
            zoom_level (int): zoom level to use on the WMTS server
            grid_length (int, optional): number of tiles on the length of the image. Defaults to 3.
            grid_width (int, optional): number of tiles on the width of the image. Defaults to 3.

        Returns:
            SatelliteView: a SatelliteView containing a custom image of the desired location
        """
        satellite_view = SatelliteView()
        satellite_view.latitude = latitude
        satellite_view.longitude = longitude
        tile_row, tile_column = compute_tile_position(
            self.matrix_set, zoom_level, longitude, latitude
        )
        satellite_view.image = self.get_concat_image(
            grid_length, grid_width, tile_row, tile_column, layer, zoom_level
        )
        return satellite_view
